\setchapterpreamble[u]{\margintoc}
\chapter{Introduction}

Computer science is ths study of what we can compute. It tries to answer questions like, are there unavoidable limits on the programs we can write? (The answer is yes.) And are there unavoidable limits on how slow some programs have to run? (The answer again is yes.) Software engineering is concerned not with whether we can build something, but how can we do it cheaply? Software engineering is concerned with how much will something cost, how fast can we make it run, and can if we squeeze it into less space---and most importantly, can we ship it on time.

Sucessful programmers need to know a mix of tricks from computer science and software engineering. And in general, the two fields benefit and grow from one another. Engineering comes up with a new, unsolved problem, and in the process of solving it, new computer science is made. Researchers to improve the techniques and those improvements make it back to the engineers, who then tackle new problems. And so the cycle goes back and forth. (In reality, everyone is doing both at the same time. But the story is cleaner this way.)

\section{The Fundamental Diagram}
Before we dive into the nitty gritty of writing programs, we should start with the singular idea at the core of it all. There is one diagram that sums up almost all of computer science and software engineering. It's so ubiquitous that I call it the \textbf{Fundamental Diagram of Programming}.

$$ \mathrm{input} \to \square \to \mathrm{output} $$

Computer science and software engineering are, at their core, about transforming inputs into outputs. Ingredients into pastries.

Example. Input: photo you took with your phone. Box: digital filters. Output: social media-worthy photograph.

Example. Input: 1 cup of whole milk, 2 cups of heavy cream, 1/2 tsp of Kosher salt, 2/3 cup of granulated sugar. Box: Ice cream maker. Output: Sweet cream ice cream.

Example. Input: a day of the week. Box: Weekly calendar. Output: The things I have to do that day.

Example. Input: the address of a website. Box: A web browser. Output: The web page at that address.

Example. Input: A form that says, "Do you like me? Yes, no, or maybe". Box: My secret crush. Output: Jubilation or heartbreak

Example. Input: Contestants on a game show. Box: The celebrity panel of judges. Output: The winner.

Example. Input: Keywords. Box: A search engine. Output: Search results related to your keywords.

This is the same as a question and answer. Request and reponse. Order and delivery. It shows up over and over and over again. Get ready to see it throughout this book. Whenever you get lost in a program---and everyone does; I do multiple times a day---stop and ask yourself, ``What inputs have I received? What outputs am I supposed to make from them?'' Start there and work your way from one to the other, forwards or backwards.

Exercise. Come up with an example that the Fundamental Diagram of Computer Science models. Draw and label your diagram.
Exercise. Now come up with another.
Exercise. And one more.


Programming can feel complicated. And a lot of times it is. But underneath all the bells and buzzwords of programming, there are really only four things you can do:

\begin{enumerate}
  \item Store information somewhere and use it later.
  \item Conditionally do something.
  \item Repeat things.
  \item Organize the machinery of (1), (2), and (3) into reusable chunks.
\end{enumerate}

If you can master those four things, you will have mastered software engineering.

\section{Storing information}
Storing information is at the heart of software. Data is king. You see it everywhere, from advertisers to political campaigns, scientific experiments, and your email. In programming, we have to decide \textit{what} data to keep around and \textit{how} to store it.

You have come across many different data storage mechanisms. Data can be saved to files on disk, stored in a database, on your computer, on another computer that you access via the internet, or on external hard drive. In programs we have other choices that we'll learn about soon.

The power of data does not come solely from storing it. Buried treasure isn't valuable until you dig it up and use it. So, too, with data. To be useful, we need to be able to retrieve and employ the data we have stored to complete a task. Many technologies have been created simply to make finding the data you're looking for fast and efficient. This is the purview of databases and key-value stores. But also of variables, objects, and data structures.

The actual mechanism you use to store and retrieve your data isn't especially important right now. All that you should remember is that in programming you can jot down some important information and use it again later.

\section{Conditional execution}
\section{Repeating}
\section{Organization}

How you structure an email is different from how you structure a novel. Good writing is tailored to the task at hand. There are two consumers of your code: the compiler, which turns it into instructions the computer can execute. But more importantly, PEOPLE---including future you! Programs are human-readable, not machine readable. Remember, the compiler is a translator; it translates the human-readable code that a \emph{human} wrote into something a human \emph{cannot} read. (Unless you're my friend EJ or my coworker Jay.) Good programming has the same hallmarks as good writing does, because that's what it is: it's a kind of writing. That's why we call them programming \emph{languages}. When you write code, you should strive to be clear. That means structuring your code in a way that shows intent: using convenient data structures and other abstractions. Encapsulating. Using simple control structures instead of fancy ones. Be explicit (no globals or other captured scope). Principle of least surprise. Make it look like someone else wrote the code: copy the style and conveniention, even if it's not your own. Cognitive load is real. Context switching is real. Keep the styles the same.

Style is a holy war. Nothing is perfect. Always trade-offs. Often it's a matter of taste and who the fuck cares. (Where to place the brackets.)
