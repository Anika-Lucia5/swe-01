\setchapterpreamble[u]{\margintoc}
\chapter{Introduction}

Computer science is ths study of what we can compute. Computer scientists try to answer questions like, are there unavoidable limits on the programs we can write? (The answer is \emph{yes}. Some programs are impossible to write no matter what.) And are there unavoidable limits on how slow some programs have to run? (The answer again is yes. We'll see an example of a performance limit later on.) Software engineering is concerned not with whether it is possible to build something---they take the fact that their project can be built for granted---but rather how can the project be built \emph{cheaply}. Software engineers are concerned with how much the project costs, how much time the software takes to run, how much memory it consumes---and, most importantly, whether the whole thing can be shipped to the customer on schedule.

Sucessful programmers need to use a mix of tricks from computer science and software engineering. Generally the two fields grow from one another. Engineers sometiems stumble onto a new, unsolved problem during the course of working on their projects. In the process of completing the project, new computer science is made. Researchers cook up new algorithms to solve outstanding problems in the field. In the process they invent new programming techniques. Those new techniques make it back to the engineers, who then apply them in new projects. And so the cycle goes on and on. What computer scientists and software engineers do aren't that different. They approach similar problems with different perspectives. To be a sucessful programmer, you will sometimes want to think like a computer scientist and sometimes like a software engineer. Fortunately, both perspectives come from the same underlying idea of computation, which can be drawn very neatly in a diagram---the \emph{fundamental diagram}.

\section{The Fundamental Diagram}
The \textbf{Fundamental Diagram} is at the heart of everything software engineers and computer scientists do.\sidenote{Full disclaimer: I might be the only person who calls this the Fundamental Diagram. But everyone should. Like reading, this diagram is fundamental.} As a programmer, you'll get to know this picture very well. It shows up in just about every concept you'll ever encounter---from the very big, to the obnoxiously small.

\begin{figure}[h]
  \input{figures/introduction/fundamental-diagram.tex}
  \caption{\label{fig:intro-fundemental-diagram} The Fundamental Diagram of computer science and software engineering in all its glory. It describes just about everything a programmer could possibly do.}
\end{figure}

Fortunately, the diagram doesn't have many parts. There are just three: the inputs, the outputs, and the transformer. The transformer takes in \emph{inputs} and \emph{transforms} them into \emph{outputs}. That's it. As a programmer, you will write software that turns specific inputs into particular outputs to accomplsh a given task. If that description sounds vague, that's because it is. Let's look at a few examples to see the Fundamental Diagram in action to get a better idea of what's going on.

\paragraph{Example (Question and Answer)} A lot of human interaction follows the input-transformer-output pattern. Questions and answers can be modeled by the fundamental diagram pretty easily. For example, ``What's your favorite color?''\sidenote{The answer is orange. Well, it is if I am the transformer being asked. You might come up with a different but correct answer. Different transformers can give different answers to the same question.} But what is the transformer in this case? The transformer is the person who gives the answer to the question; she listens to a question asked by somebody else, processes what it means, and then produces an answer. For historical reasons---think ancient Greek history---sometimes the role of the transformer in a Q\&A session is called an \emph{oracle}.

\begin{figure}[h]
  \input{figures/introduction/example-question-answer.tex}
  \caption{\label{fig:intro-example-question-answer} Fundamental diagram for a question, oracle, and answer.}
\end{figure}

\paragraph{Example (Request and Response)}The same can be said of slightly different kind of speech act called a \emph{request}. People make requests all the time. ``Can you close the door, please?'' ``May I have the lobster sandwich and a raspberry lime rickey?'' ``That'll be \$49.99, please.'' Each of these statements intend to turn simple words into actions that produce some physical effect---producing closed door, a lobster sandwich and a raspberry lime rickey, or money totaling \$49.99.

\begin{question}
  Identify the inputs, outputs, and transformers for the requests above.
\end{question}

\begin{question}
  Draw the fundamental diagrams for each of the requests above.
\end{question}

On the web, requests are ubiquitous. When you open a web browser and type in the address of a web page, the web browser makes a formal request to the machine located at that address. \sidenote{In the same way individual people have street addresses---like Sirius Black, who resided at 12 Grimmauld Place, London---computers have internet addresses, too. These computers are called \emph{web servers}. Like the computer which resides at the address \texttt{www.dafk.net}.\vskip 5pt Individual web pages reside on web servers. For example, the webapge \texttt{what} resides on the computer with the address \texttt{www.darfk.net}. Its full address is \texttt{www.darfk.net/what}.} The terminology for the actors in a web request comes from the restaurant industry. At restaurants, clients make requests to people called servers, who fulfill their clients' requests (usually with the help of many other people who are not client-facing).

This pattern of request and response is exactly how the world wide web works. The piece of software that initiates the request is called the \emph{client}. Because this is the software that human users can see, people sometimes say client technology is \emph{front end} technology. The software that receives, processes, and sends back a response to the client is called the \emph{server}. The server is not something that human users interact with directly. We don't get to see what the server is doing, only the response that it produced. This is a lot like how clients at a restaurant don't get to interact with the kitchen directly. Instead they get to experience the finished product---but they don't get know how the sausage is made, so to speak. Because the server's work to transform a request into a full web page response is opaque to the user, we say that servers a \emph{back end} technology.

\begin{figure}[h]
  \input{figures/introduction/example-request-response.tex}
  \caption{\label{fig:intro-example-request-response} Fundamental diagram for a request, server, and response.}
\end{figure}

The client-server architecture, like the fundamental diagram, is deceptively simple and yet it powers the whole of the internet.\sidenote{Software engineers call the organization of data flows an \emph{architecture}. In this case, the flow of information is the request from the client to the server and the response from server to client.} Web programming is a specialized collection of technologies, many of which we'll encounter in this series. When you're bushwacking the jargon and buzzwords of the web technology jungle, stop and remember Figure \ref{fig:intro-example-request-response}: just two arrows and a box in the middle. Almost all of the latest and greatest technologies are just fancy ways to request some piece of data from a server. Always keep this picture in mind.

\paragraph{Example (Making Ice Cream)} Recipes are hands-down the tastiest kinds of transformers.Recipes explain how to transform ingredients into prepared dishes. Here's one I like because it's quick, easy, and the result is something near and dear to my heart: ice cream.

\begin{marginfigure}
  \input{figures/introduction/example-ice-cream.tex}
  \caption{\label{fig:intro-example-ice-cream} Total preparation time is about 15 minutes plus a 20 minutes soft freeze in the ice cream maker followed by an overnight hard freeze in the freezer.\vskip 5pt Milk by Wawan Hermawan and ice cream by Landan Lloyd from the Noun Project.}
\end{marginfigure}

Up until now, each transformer we've described takes exactly one input and produces a single output. Here is our first example of a transformer that takes multiple inputs to produce its output. It is not uncommon for a transformer to take multiple inputs. There are very few recipes that require just a single ingredient. So, too, programs often need to use combine multiple inputs to generate a desired output.

Let's look at the process to transform a few ingredients into ice cream in some detail. Below is a kind of step-by-step list of instructions that transform the input ingredients milk, cream, sugar, and salt, into ice cream. Each step goes on its own line. As a general rule, steps should be kept as simple as possible. Complex steps should be broken up into multiple, simpler steps. This strategy makes it easier for the person preparing the recipe to understand and execute. The programs we write to transform inputs into outputs will have a very similar character.

\suppresslinenumbers
\begin{lstlisting}[caption={\label{listing:intro-ice-cream} Ice cream transformer. It's as short as it is sweet.}, escapeinside=$$, firstnumber=0]
$\textbf{Inputs:}$ 1 c. whole milk
        2 c. heavy cream
        2/3 c. sugar
        1/2 tsp. Kosher salt

$\textbf{Output:}$ Sweet cream ice cream
$\reactivatelinenumbers$
Place the milk, heavy cream, sugar, and salt in a bowl.
Mix until the sugar has completely dissolved.
Pour the ice cream base into an ice cream maker.
Run the machine until the base mixture firms up.
Transfer the cold cream into a sealed container.
Chill the container in a freezer overnight.
\end{lstlisting}

Did you notice that our great big ice cream transformer is made up of three smaller input-output transformers? The first one decribed on lines 1--2. It turns the input ingredients into a liquid base mixture. The next one on lines 3--4 takes as input the base mixture and outputs a cold cream. While cold cream is delicious, it melts extremely rapidly. And so the recipe finishes with the transformer on lines 5--6, which takes as input the cold cream and freezes it until to produce bona fide ice cream.

\begin{figure*}[h]
  \input{figures/introduction/example-ice-cream-pipeline.tex}
  \caption{\label{fig:intro-example-ice-cream-pipeline} The steps inside transformers are often simpler transformers. The transfromation that produces ice cream from ingredients is made up of three successive transformers. The output of one transformer is the input to the next transformer.}
\end{figure*}

Figure \ref{fig:intro-example-ice-cream-pipeline} illustrates that old saying, ``One transformer's output is another transformer's input.'' And that is the real power of the fundamental diagram. You can chain copies of it together to produce more and more complicated flows of inputs and outputs. In this case, we chained together three transformers in the simplest way possible, in a line, one after the other. The \emph{pipeline} pattern is very common in software architecture. In fact, many of the applications in ``big data'' reduce to pipelines of transformers, no different conceptually to the ice cream pipeline above. When we work with command line tools, we will meet the pipe operator that feeds the output of one program as the input to another.\sidenote{The pipe operator notated by the symbol `\texttt{|}`. It's that shift character on the backslash key. Now go lay some pipe!} It acts like a pipe for the information to flow through. Hence the name \emph{pipe}.

\begin{question}
  In the style of Listing \ref{listing:intro-ice-cream}, write the inputs, outputs, and steps to create a grilled cheese sandwich.
\end{question}

\begin{question}
  Draw a fundamental diagram for your grilled cheese listing.
\end{question}

\begin{question}
  Come up with three more examples that can be modeled by the fundamental diagram.
\end{question}

\subsection{Compilers} One of the most important transformer in programming is type of program called a \emph{compiler}. Compilers translate programs from one language into another---specifically, from a \emph{source language} that humans can read, write, and understand to a \emph{target language} that computers can interpret and execute.

\begin{figure}[h]
  \input{figures/introduction/example-compiler.tex}
  \caption{\label{fig:intro-example-compiler} Fundamental diagram for source code compilation into machine-readable bytecode.}
\end{figure}

It may seem surprising that the code you write is \emph{not} for the computer but for people---like yourself! The source code that you write needs to be converted into machine-friendly instructions that can be executed by hardware. Compilers make programming accessible to people who do not hold PhDs in mathematics, and they are one of the great achievements in the history of computing. Without compilers we would need to know absolutely everything about the hardware your program runs on---how its memory is structured, how many registers it has---and to manually keep track of and manipulate the location of your data in memory. You can program in a \emph{low level language} like Assembly if you want to get cozy with the bare metal. Since there are so many more things to keep track, low-level language programs tend to be very long and hard to follow. By comparison, \emph{high level languages} cannot be executed by the machine directly and require an extra compilation step that generates the low-level code for you. Generally, this extra step is worth it. Programs written in high level languages are shorter and easier to follow than their low level counterparts.

As an example, compare two implementations of the classic program \textsf{Hello, World}. The first one is written in NodeJS, a high level language.

\begin{lstlisting}[caption={\label{listing:intro-hello-world-nodejs} Hello, World! in NodeJS.}, escapeinside=$$, firstnumber=1]
// hello.js
"use strict";

console.log("Hello, World!");
\end{lstlisting}

The second implementation is written in Assembly, a low level language that mimics the architecture of the hardware that the program runs on.

Be very thankful that you have a friendly compiler that can translate your directions into machine-readable instructions.

\textbf{TODO: Hello World in Assembly} https://tldp.org/HOWTO/Assembly-HOWTO/hello.html Say that assembly maps 1:1 to machine architecture using an \emph{assembler}. Often source code gets compiled to assembly instructions then assembled into machine instructrions. One assembler per type of chip architecture. Why talk about this at all? The important part is that software needs to run on hardware. At the end of the day, there is a physical location to all of the information in a program. (What about virtualization? Well, those virtualizations model the hardware, so they have to model the physical location, too. And those virtualizations run on real hardware. So even programs that simulate computers need to run on real computers. The data has to live in a physical location at some point. It can't be turtles \emph{all} the way down.)

Make a fundamental diagram of source code $\to$ compiler $\to$ assembly code $\to$ assembler $\to$ machine instructions.

\textbf{TODO: Grace Hopper.
Fran Allen: https://www.ibm.com/blogs/research/2020/08/remembering-frances-allen/}

\subsection{Interpreters}

Interpreters are an interactive version of compilers. Instead of writing all of the code out at once and compiling it to a finish program, interpreters let you type in instructions one at a time and run your program incrementally. They are a playground, a sandbox to try things out.

[Insert fundamental diagram for interpreter]

Reference \textit{Structure and Interpretation of Computer Programs}.

JavaScript is an interpreted language. It is useful to try things out in an interpreter while writing a program. We will use the NodeJS interpreter a lot to develop our programs as we write them.

\section{Four Friends of Programming}

There are lots of things to learn about engineering. New technologies are built every single day. And it is difficult to keep up. The shear number of things to know can be overwhelming. But fear not! There actually aren't that many different things you can do with a programming language. In fact, there are only four.\marginnote{The fact that there are only four things you can do is something of a theoretical marvel. It is related to \emph{Church-Turing thesis} and lies as the heart of the foundations of computing. Lucky for us, it means we need to learn only four concepts. Actually the fourth one, organization and reuse, is merely a convenience for us humans.} Any new technology or technique you run across is a cousin to one or more of the four friends you will make in this chapter. The four things you can do in a programming language are:

\begin{enumerate}
  \item \textbf{Store data and retrieve it later to use.}
  Your friend for the pillar of data storage and retrieval is a \emph{variable}. Other instances of this pillar include files, databases, networked resources, and web pages on the Internet. At their heart, however, they're all about stashing some information somewhere and fetching it later.

  \item \textbf{Conditionally do something.}
  Your friend for the pillar of conditional execution is the \textsf{if} statement. Other examples of this pillar include associative arrays, pattern matching, and \textsf{switch} statements. These technologies exist to add decision-making into programs. Conditional elements put the ``sometimes'' into programs that would otherwise be ``always'' based on context and circumstance.

  \item \textbf{Repeat things.}
  The ability to repeat things quickly is what makes computers so useful. Your friend for the pillar of repetition is the \textsf{for}~loop. Other examples of this pillar include \textsf{while}~loops and \textsf{do-while}~loops, recursion, and coroutines. At their core, however, the whole point is to repeat something.

  \item \textbf{Organize 1--3 into individual pieces.}
  This last pillar isn't technically required, but it perhaps the most useful.\marginnote{See, for example, the controversy about whether or not to put curly braces on their own line or not: https://en.wikipedia.org/wiki/Indentation\_style.} It's all about organizing our programs into pieces that are easy for people to read, understand, expand, troubleshoot, and fix. This pillar could also be called \emph{programming style}. Your friend from this pillar is \emph{function}. Other members of the pillar include libraries, modules, closures, classes, and design patterns\marginnote{People write full books on programming style and they almost always disagree on what ``best'' practices are.}. Since style is often a matter of taste, this pillar is the most contentious and is the basis of many religious wars.
\end{enumerate}

That's it! Master the four pillars of programming and you can confidently tackle any project. That is not to say that these four skills are easy to master. Mastery is hard work. But when you find yourself learning something new, ask yourself, ``Which of my four friends is this new friend most like?'' Or if you are stuck implementing a solution and aren't sure what to do, ask yourself, ``Which of my four friends could help me most right now?''

\textbf{TODO: Add questions about the four pillars/abilities.}

\textbf{TODO: Remark that programming languages are programs.} Compilers and interpreters are programs themselves, and therefore need to be programmed in a programming language.

If ther are only four things you can do in any programming language, why are there so many? You need to be able to do 1--3 in any general programming language. How do you do that and how you organize the code is all up to 4. Programming languages fall into certain ways of organizing your thoughts---these styles of thinking and orgaization are called paradigms. Most languages will be multi-paradigm.

Examples Imperative: C, Algol, Fortan, NodeJS. Declarative: SQL, Metafont, Prolog. Object based: Java.  Stack-based: PostScript, Forth. Functional: Haskell. Erlang. List-based: LISP, Scheme. Array-based: Matlab, Julia, Numpy. Multi-paradigm: Python, Swift.\marginnote{There are as many paradigms as there are ways of thinking. APL is insane-o. Here is a program that finds prime numbers in APL. \texttt{PRIMES : (\textasciitilde R$\in$R$\circ$.$\times$R)/R$\leftarrow$1$\downarrow$$\iota$R}}

Languages make some tasks easier, but at the cost of making other harder. Bob Marley, ``Truth is everybody is going to hurt you: you just gotta find the ones worth suffering for.'' Everything is a trade-off in design, including programming language design. You can technically create a mobile app in Julia, but it would be very, very, very hard. You can implement scientific computing in NodeJS, but it would be very, very hard. Choose a good tool for the task at hand.

Remember that programming languages are implemented by their compiler---the compiler converts text files into machine executable code. But the compiler is just a program, so it has to be written in a programming language. There is source code for the compiler that a compiler compiles. The standard implementation of Python is written in C, but Jython is Python implemented in Java.

\subsection{Data Types}
Before we can talk about storing and using information, we need to talk about how we represent information in programs in the first place. In programming, we use data types to represent information. A \emph{data type} is a collection of values and operations\marginnote{The transformers that operate on the values of a data type are called \emph{operators}, or, more generally, \emph{functions}. In this text, I'm going to use the two terms interchangeably.} that you can apply to those values. Each piece of information in a program has three parts:

\begin{itemize}
  \item Name
  \item Data Type
  \item Value
\end{itemize}

Since each value in a program belongs to a data type---data types are how we represent information, after all---type and value are always associated with a piece of data. Names, however, are optional. When an element of a data type is associated with a name, we call it a \emph{variable}. A variable is a data type value that has a name. An element of a data type that does not have a name is called a \emph{literal value}. The diffrence between a variable and a literal value is that you can use the name of a variable to reference it later. Literal values, however, need to be used immediately and cannot be referened later in your program---because they don't have a name to call them later!

NodeJS has a handful of built-in data types. The most familiar one will be the \textsf{Number} data type. You won't be surprised to learn that the \textsf{Number} data type is used to represent numerical values in NodeJS.

Since \textsf{Number} is a data type, we need to know two things:
\begin{enumerate}
  \item What are the \emph{values} of \textsf{Number}?
  \item What are the \emph{operators} that act on values of \textsf{Number}?
\end{enumerate}

The reason we're staring with the \textsf{Number} data type is because the values of \textsf{Number} can be expressed in NodeJS in roughly the same way you'd write them anywhere else: by typing digits of the number you want to use. Node can handle positive and negative values, as well as values with fractional parts using decimal notations. For example, let's type a few literal \textsf{Number} values into the NodeJS interpreter and see how it responds:

\marginnote{
You always can---and often should!---write a box diagram for data in your programs. Here are box diagrams for the other \textsf{Number} values we typed into the interpreter.

\begin{tabular}{|c|c|c|}
  \hline
  \textsc{Name} & \textsc{Type} & \textsc{Value}\\
  \hline
  --- & \textsf{Number} & \texttt{-8}\\
  \hline
\end{tabular}

\begin{tabular}{|c|c|c|}
  \hline
  \textsc{Name} & \textsc{Type} & \textsc{Value}\\
  \hline
  --- & \textsf{Number} & \texttt{0.1}\\
  \hline
\end{tabular}

\begin{tabular}{|c|c|c|}
  \hline
  \textsc{Name} & \textsc{Type} & \textsc{Value}\\
  \hline
  --- & \textsf{Number} & \texttt{-0.2}\\
  \hline
\end{tabular}
}

\suppresslinenumbers
\begin{lstlisting}
> 144
144
> -8
-8
> 0.1
0.1
> -0.2
\end{lstlisting}
\reactivatelinenumbers


The NodeJS interpreter interprets the symbol \texttt{144} into the \textsf{Number} value 144. Remember that each piece of information in a program has three parts: a name, a type, and a value. Let's draw a box diagram for the symbol \texttt{144}.

\begin{table}[h!]
  \begin{tabular}{|c|c|c|}
    \hline
    \textsc{Name} & \textsc{Type} & \textsc{Value}\\
    \hline
    --- & \textsf{Number} & \texttt{144}\\
    \hline
  \end{tabular}
  \caption{Box diagram for the literal value \texttt{144}}
\end{table}

The symbol \texttt{144} looks like the number 144 you've used outside of programs, but it is not! NodeJS turns the symbol \texttt{144} into a \textsf{Number} value under the hood that behaves like the like number 144. It was \emph{programmed} that way. And the program works so well that is easy to forget that it exists and is doing work at all. Sometimes, however, the fact that we are working with programs that simulate numbers and not working with numbers themselves does show through. This fact is especially evident when working with numbers with fractional parts.

\marginnote{There is nothing special about the box diagrams for the special \textsf{Number} values. They have a type and value, just like any other piece of data.

\begin{tabular}{|c|c|c|}
  \hline
  \textsc{Name} & \textsc{Type} & \textsc{Value}\\
  \hline
  --- & \textsf{Number} & \texttt{Infinity\phantom{-}}\\
  \hline
\end{tabular}

\begin{tabular}{|c|c|c|}
  \hline
  \textsc{Name} & \textsc{Type} & \textsc{Value}\\
  \hline
  --- & \textsf{Number} & \texttt{-Infinity}\\
  \hline
\end{tabular}

\begin{tabular}{|c|c|c|}
  \hline
  \textsc{Name} & \textsc{Type} & \textsc{Value}\\
  \hline
  --- & \textsf{Number} & \texttt{\phantom{inf}NaN\phantom{ity}}\\
  \hline
\end{tabular}
}

Before we get to how \textsf{Number} values do not behave identically to numerical values you're used to, it's worth mentioning three special \textsf{Number} values that exist in NodeJS. They are identified by the symbols \texttt{Infinity}, \texttt{-Infinity}, and \texttt{NaN}. The first two represent and represent positive and negative infinity, respectively. Third, \texttt{NaN}, usually pronounced ``nan'', represents a special value that is \emph{not a number}. \texttt{NaN} appears when programs try to combine numerical values with non-numerical values. We'll encounter \texttt{Infinity}, \texttt{-Infinity}, and \texttt{NaN} later on, but for now it's good enough simply to know that they exist.

\begin{question}
  Is \texttt{-0.2} a variable or a literal value? How do you know?
\end{question}

\begin{question}
  Is \texttt{NaN} a variable or a literal value? How do you know?
\end{question}

\begin{question}
  Draw the box diagrams for \texttt{100}, \texttt{3.14159}, \texttt{-64}, and \texttt{0}.
\end{question}

Numbers would be useless if all we could do was type them on after another. The reason numbers show up so often, in computing and in life, is because they can be combined, substracted, compared, exponentiated, square-rooted, and a million other things. Numbers are useful because of the operators that transform input numbers into output values. That idea is so important, it bears repeating:

\begin{quotation}
  Values are not useful on their own. Transformations\marginnote{You might even say that transformations are fundamentally important.} that relate values to each other are what make them useful.
\end{quotation}

NodeJS has a handful of built-in operators that transform \textsf{Number} values into other \textsf{Number} values that you are probably familiar with. Arithmetic operators like addition (\texttt{+}) and subtraction (\texttt{-}) follow a syntax that is commonly used outside of programming. The arithmetic operators are special in JavaScript in that they use infix notation---you place the operator in between its inputs. For example, to add the \textsf{Number} values \texttt{4} and \texttt{5} you type:

\suppresslinenumbers
\begin{lstlisting}
> 4 + 5
9
\end{lstlisting}

Other arthmetic expressions work more or less as you would expect, except that multiplication is denoted by an asterisk (\texttt{*}) and exponentiation is denoted by a double asterisk (\texttt{**}). The remainder operator (\texttt{\%}) is an old favorite among programmers. It calculates the remainder when one whole number has been divided by another. In the example below \texttt{4 \% 5} evaluates to \texttt{4} because 5 goes into 4 zero times and leaves 4 left over.

\begin{table}
  \begin{tabular}{lccc}
    Operation & Operator & Example & Evaluation\\
    \hline
    Addition & \texttt{+} & \texttt{3 + 12.5} & \texttt{15.5}\\
    Subtraction & \texttt{-} & \texttt{-7.2 - 3} & \texttt{-10.2}\\
    Multiplication & \texttt{*} & \texttt{144 * 0} & \texttt{0}\\
    Division & \texttt{/} & \texttt{12 / 4} & \texttt{3}\\
    Exponentiation & \texttt{**} & \texttt{3 ** 4} & \texttt{81}\\
    Remainder & \texttt{\%} & \texttt{21 \% 10} & \texttt{1}\\
  \end{tabular}
  \caption{The arithmetic operators}
\end{table}

\begin{lstlisting}
> 4 - 5
-1
> 4 * 5
20
> 4 / 5
0.8
> 4 ** 5
1024
> 4 % 5
4
> 6 % 5
1
\end{lstlisting}

\begin{figure}
  \textbf{TODO: Fundamental diagram for addition}
\end{figure}
\begin{question}
  Why does \texttt{6 \% 5} evaluate to \texttt{1}?
\end{question}

\begin{question}
  Use the Node interpreter to find the following values:
  \begin{enumerate}
    \item The sum of counting numbers 1 to 10
    \item $13^{16}$
    \item One-tenth of 0.2
    \item The remainder when 143 has been divided by 3
  \end{enumerate}
\end{question}

\begin{question}
  Draw the fundamental diagram for subtraction.
\end{question}

Remember that we said \texttt{144} is not the number 144, but just a program that simulates the number 144? What did we mean by that? It's easiest to understand that even data types as central computing as numeric values are just programmatic models of the real thing when our experience in the real world doesn't match the model. What should you get when you multiply \texttt{0.1} by \texttt{0.2}? Compare that with that you actually get.

\begin{lstlisting}
> 0.1 * 0.2
0.020000000000000004
\end{lstlisting}

Look at that! There is a 4 where there shouldn't be. That errant 4 is an artifact of the representation NodeJS uses under the hood to implement numeric values.

Before you start hating on NodeJS, think about the task at hand. How many numbers are there? An \emph{infinite} number of them.\marginnote{Worse than just infinite. The real numbers, which include pathological numbers like $\pi$ and $e$, are \textit{uncountably infinite}. That's a larger infinity than the number of counting numbers or fractions.} How much memory does your computer have? I'm willing to bet it's less than infinite. Off the bat, that should make you wonder whether its possible to implement numeric values with infinite precision.

Instead, NodeJS uses a scheme called \textit{floating point arithmetic} represent numeric values. \marginnote{Never, \emph{ever}, EVER use floating point numbers to represent money. If you do, the IRS will come knocking on your door to explain all the money you invented and lost.} That choice is a compromise between having numeric values that act like numbers most of the time, within a tolerance that is acceptable for most applications, and still fitting in memory and being fast. Most programming languages use floating point arithmetic to implement numeric values under the hood. If you work on financial applications, you should not use floating point values. And if you end up doing scientific computing, you'll want to learn about errors that occur because we cannot implement infinitely precise numbers. That field of study is called \emph{numerical analysis}.

Now that we have a \textsf{Number} data type, complete with values and operators to play with, let's try to break it! In school, teachers often say you can't divide by zero. Let's see what happens when we try in NodeJS.

\begin{lstlisting}
> 8 / 0
Infinity
> -9 / 0
-Infinity
\end{lstlisting}

In JavaScript, you \emph{can} divide by zero. Division by zero is defined in this simulation of number. Depending on whether you divide a positive number or a negative number by zero, you get the \textsf{Number} value \texttt{Infinity} or \texttt{-Infinity}. Both are perfectly good \textsf{Number} values and work more-or-less the same as any other \textsf{Number} value. Note that an expression that evaluates to \texttt{Infinity} (or any other \textsf{Number} value) is \emph{not} an error. In other languages, division by zero would cause an error.

\begin{lstlisting}[caption={Try this at home, kids! A stack trace caused by a \texttt{ZeroDivisionError} in a Python interpreter.}]
>>> 8 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
\end{lstlisting}

In some programming languages, like Python, division by zero is totally verboten and will cause your program to crash. Even an expression that evaluates to the not-a-number \textsf{Number} value \texttt{NaN} is \emph{not} an error. Since \texttt{NaN} is a value, it can be the legitimate result of a calculation. The fact that division by zero is legal and evaluates to \texttt{Infinity} is neither right nor wrong, but an implemenation choice that the folks who designed NodeJS decided on. They could have gone the same route as Python by forbiding division by zero entirely, but they didn't. And that is not objectively better or worse. It just means the rules in NodeJS are different than in Python, and that's okay.

\begin{question}
  Draw the fundamental diagram for the expression \texttt{-9 / 0}.
\end{question}

\begin{question}
  What do the following expression evaluate to?
  \begin{enumerate}
    \item \texttt{Infinity + 8}
    \item \texttt{8 - Infinity}
    \item \texttt{-Infinity / 12}
    \item \texttt{Infinity / Infinity}
  \end{enumerate}
\end{question}

\begin{question}
  In plain English, what do the expressions \texttt{5 \% Infinity} and \texttt{Infinity \% 5} mean?
\end{question}

\begin{question}
  What do the expressions \texttt{5 \% Infinity} and \texttt{Infinity \% 5} evaluate to? Why are they different? Do you agree with the programming language designers choice of values for the results of each expression?
\end{question}

\begin{question}
  Draw the fundamental diagram for the expression \texttt{Infinity \% 5}.
\end{question}


\section{Algorithms}

Now that we have the \textsf{Number} data type, we have numeric \emph{values} and arithmetic \emph{operators} that can transform numeric values into other numeric values. So what good is that? The power of data types comes from how you can string transformations of values one after another in a prescribed way to accomplish something. Enter algorithms.

An \emph{algorithm} is a step-by-step description of how to do something. An algorithm is not a solution to a problem. It is a procedure for coming up with a solution given inputs. In other words, an algorithm describes a method for transforming inputs into outputs. You know how to do many things in real life---you can tie your shoes, shuffle cards, wash the dishes, make scrambled eggs, and install an app on your phone. In each task you follow a method. You already know lots of algorithms!\sidenote{You are just like the Mr.~Jourdain, in Moli\`ere's \textit{Le Bourgeois Gentilhomme}, who learns that he has been speaking prose his whole life without knowing it. You, too, have been implementing algorithms all your life!}

Once an algorithm exists, it can be implemented and executed in many different ways. Originally, the term ``computer'' was a job title for a people. Human computers executed algorithms by hand with pencil and paper. Today, programmers describe algorithms in programming language code. Each program is an \emph{implementation} of the algorithm. It is perfectly possible to have multiple implementations for the same algorithm---say, to write a progam for Android and another that does the same thing on iOS. Each version is a separate implementation of the same set of algorithms. And, in fact, we will implement some algorithms multiple times in this book as we learn more programming concepts.

\begin{figure}
  \input{figures/introduction/algorithm-fundamental-diagram.tex}
  \caption{\label{fig:intro-algorithm-fundemental-diagram} An algorithm provides the process to turn inputs into outputs. An implementation of the algorithm is the program that you run on actual inputs to produce particular outputs.}
\end{figure}


\begin{question}
  In plain English, describe an algorithm for making a peanut butter and jelly sandwich. (If you aren't fond of peanut and jelly, substitute a sandwich you prefer better.) Number each step in your description.
\end{question}

\begin{question}
  Describe an algorithm for adding two positive integers together. Number each step in your description. Apply your algorithm on the inputs 119 and 246.
\end{question}

\begin{question}
  List three more things you know how to do and describe step-by-step instructions to teach someone else how to do one of them.
\end{question}

[\textbf{TODO:} mention that computer used to be the job title of a person! How would you calculate the square root of a number? How do computers do it now? An algorithm. It has to be programmed. Calculating a square root is a program.]

A recipe for a cake is not the same thing as a cake. \marginnote{Let's say it all together: \textsf{Algorithm~$\neq$~Solution}.} Just as a recipe is a procedure to produce cake, an algorithm is a procedure for turning inputs into outputs that solve a task. We will use an algorithm to turn a guess for the square root of 2 into a numeric approximation of the square root of two. \marginnote{Why are we only approximating $\sqrt{2}$? Because $\sqrt{2}$ is an irrational number. That means its decimal representation 1.41421356237\dots goes on forever without repeating. We'd run out of memory before we got all of the digits down. So we have to settle for an approximation that suits our tolerances. As an aside, only 15 digits of $\pi$ are good enough for NASA to plan interplanetary navigation for Voyager 1, which is currently about 12.5 billion miles away!} Keep in mind that the method we describe is not the square of two itself. In fact, the method is general enough to calculate the square root of any number, not just of two!

The method we will use is called Newton's method. And while we won't discuss why Netwon's method works here, it is worth noting that to execute an algorithm you don't need to understand how the algorithm was concocted in the first place. That's the point of algorithms! They are so well specified, that even cold, unthinking pieces of electrified rocks can run them. In your career as a programmer, sometimes you will need to come up with an algorithm of your own to solve a problem. Other times, you will need to implement an algorithm that someone else came up with. It is good and necessary to be able to do both. For now, let's implement an algorithm that's between 300 and 4000 years old\sidenote{The Babylonian method for computing square roots is a special case of Netwon's method.}.

Here is a description of what we're going to do:

\begin{lstlisting}[caption={Newton's method for calculating square roots}]
Inputs: n, the square of the number we're trying to calculates
        guess, our current guess for sqrt(n)

1a. If guess and n / guess are sufficiently close to each other
1b.   Stop and return the current value of guess
2. Otherwise update guess with the average of guess and n / guess.
3. Go to Step 1
\end{lstlisting}

Before we try execute our algorithm, let's try to understand it a little bit. There are three steps, and at each step is one of your four friends! The entire algorithm describes a transformer of two inputs---the number we'd like to square root \texttt{n}, and a guess of the square root of \texttt{n}---and produces one output---an approximation to the square root of \texttt{n}. Since the algorithm describes a transformer, it has a fundamental diagram.

\begin{figure*}
  \input{figures/introduction/newton-fundamental-diagram.tex}
  \caption{\label{fig:intro-newton-fundamental-diagram} Newton's method takes as input a squared number $n$ and outputs an approximation to $\sqrt{n}$.}
\end{figure*}

\begin{question}
  Which of your four friends is in step 1? Explain your answer. (\textit{Hint:} There may be more than one friend hanging out per step.)
\end{question}

\begin{question}
  Which of your four friends is in step 2? Explain your answer.
\end{question}

\begin{question}
  Which of your four friends is in step 3? Explain your answer.
\end{question}

\begin{question}
  Which line describes the output of the transformer? Explain your answer.
\end{question}

Newton's method works by successively honing in on the square root of the input number \texttt{n}. At each step, the true square root is between the current \texttt{guess} and the value \texttt{n / guess}. So we check to see if those two values are close enough to each other. If they are within our tolerance, we stop. The current guess is good enough for our approximation. If they are not, we continue to update \texttt{guess} to get a value that is closer to the square root, making a sequence of progressively better guesses as we go along.

As it is described, Newton's method requires only numeric values and arithmetic operators. That means we can already implement the algorithm! Let's try to calculate $\sqrt{2}$ to three decimal places. We'll start with an initial guess of 1, though you could start with any guess you like\sidenote{The closer your initial guess is to the actual square root, the faster the Newton's method converges.}.

You can (and \emph{should}) type the following into a JavaScript or Node interpreter to follow along. Each line beginning with \texttt{>} is a line that you type. Then Node will evaluate your instructions and display the evaluation on the next line. There are special lines that begin with \texttt{//}. These lines contain \emph{comments}. Comments are used widely in programming to help out human readers---machines blissfully ignore them. Comments describe tricky bits of code; remind ourselves why we did something that at first glance looks counterintuitive or wrong; or leave a note explaining how you were feeling at the moment you wrote the code. Comments are the unsung heroes of programming, and you should write lots and lots of comments in your own code. We'll talk about them more as we go on. In this example, comments annotate exactly which step of Newton's method we're calculating and keeping track of the values involved in the algorithm.

\begin{lstlisting}[caption={\label{listing:intro-newton}Calculating $\sqrt{2}$ to three decimal places using Newton's Method}, escapeinside=$$]
> $\color{gray}// \textbf{Initial guess:} 1$
> 1
1
> $\color{gray}// \textbf{Step 1a.} Check if the current guess is close enough.$
> 1 - 2/1
0.5
> $\color{gray}// 0.5 is not close enough. Keep going.$
> $\color{gray}// \textbf{Step 2.} Update the current guess.$
> (1 + 2/1)/2
1.5
> $\color{gray}// The new guess is 1.5.$
> $\color{gray}// \textbf{Step 3.} Go back to Step 1.$
> $\color{gray}// \textbf{Step 1a.} Check if the current guess is close enough.$
> 1.5 - 2/1.5
0.16666666666666674
> $\color{gray}// 0.16666666666666674 is not close enough. Keep going$
> $\color{gray}// \textbf{Step 2.} Update the current guess.$
> (1.5 + 2/1.5)/2
1.4166666666666665
> $\color{gray}// The new guess is 1.4166666666666665.$
> $\color{gray}// \textbf{Step 1a.} Check if the current guess is close enough.$
> 1.4166666666666665 - 2/1.4166666666666665
0.004901960784313486
> $\color{gray}// 0.004901960784313486 is 2 decimal places correct.$
> $\color{gray}// But we want three. Keep going.$
> $\color{gray}// \textbf{Step 2.} Update the current guess.$
> (1.4166666666666665 + 2/1.4166666666666665)/2
> $\color{gray}// The new guess is 1.4142156862745097$
> $\color{gray}// \textbf{Step 3.} Go back to Step 1.$
> $\color{gray}// \textbf{Step 1a.} Check if the current guess is close enough.$
> 1.4142156862745097 - 2/1.4142156862745097
> 0.0000042477996395895445
> $\color{gray}// \textbf{Step 3.} go to Step 1 again.$
> $\color{gray}// \textbf{Step 1a.} Check: 0.0000042477996395895445 tells us we$
> $\color{gray}// are correct to 5 decimal places, which is good enough.$
> $\color{gray}// \textbf{Step 1b.} Stop! Return the current guess \textbf{1.4142156862745097}.$
> $\color{gray}// That value is our output.$
\end{lstlisting}

\begin{question}
  How many times did we repeat the loop in Listing \ref{listing:intro-newton}? Why did we stop?
\end{question}

\begin{question}
  What inputs would you supply to use Newton's method to find the square root of three?
\end{question}

\begin{question}
  Use Newton's method to calculate $\sqrt{3}$ to three decimal places. How many iterations of the loop did you execute in your calculation?
\end{question}

\begin{question}
  Use Newton's method to calculate $\sqrt{4}$ to three decimal places three times using 1, 2, and 100 as initial guesses. How many iterations of the loop did you execute in your calculation for each different initial guess?
\end{question}

\begin{question}
  Use Newton's method to calculate $\sqrt{5}$ to three decimal places. How will you choose your initial guess? How many iterations of the loop did you execute in your calculation?
\end{question}
