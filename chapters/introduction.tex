\setchapterpreamble[u]{\margintoc}
\chapter{Introduction}

Computer science is ths study of what we can compute. Computer scientists try to answer questions like, are there unavoidable limits on the programs we can write? (The answer is \emph{yes}. Some programs are impossible to write no matter what.) And are there unavoidable limits on how slow some programs have to run? (The answer again is yes. We'll see an example of a performance limit later on.) Software engineering is concerned not with whether it is possible to build something---they take the fact that their project can be built for granted---but rather how can the project be built \emph{cheaply}. Software engineers are concerned with how much the project costs, how much time the software takes to run, how much memory it consumes---and, most importantly, whether the whole thing can be shipped to the customer on schedule.

Sucessful programmers need to use a mix of tricks from computer science and software engineering. Generally the two fields grow from one another. Engineers sometiems stumble onto a new, unsolved problem during the course of working on their projects. In the process of completing the project, new computer science is made. Researchers cook up new algorithms to solve outstanding problems in the field. In the process they invent new programming techniques. Those new techniques make it back to the engineers, who then apply them in new projects. And so the cycle goes on and on. What computer scientists and software engineers do aren't that different. They approach similar problems with different perspectives. To be a sucessful programmer, you will sometimes want to think like a computer scientist and sometimes like a software engineer. Fortunately, both perspectives come from the same underlying idea of computation, which can be drawn very neatly in a diagram---the \emph{fundamental diagram}.

\section{The Fundamental Diagram}
The \textbf{Fundamental Diagram} is at the heart of everything software engineers and computer scientists do.\sidenote{Full disclaimer: I might be the only person who calls this the Fundamental Diagram. But everyone should. Like reading, it is fundamental.} As a programmer, you'll get to know this picture very well. It shows up in just about every concept you'll ever encounter---from the very big, to the obnoxiously small.

\begin{figure}[h]
  \input{figures/introduction/fundamental-diagram.tex}
  \caption{\label{fig:intro-fundemental-diagram} The fundamental diagram of programming in all its glory. It describes just about everything a programmer could possibly do.}
\end{figure}

Fortunately, the diagram doesn't have many parts. There are just three: the inputs, the outputs, and the transformer. The transformer takes in \emph{inputs} and \emph{transforms} them into \emph{outputs}. That's it. As a programmer, you will write software that turns specific inputs into particular outputs to accomplsh a given task. If that sounds vague, it is. Let's look at a few examples to see the Fundamental Diagram in action.

Example. Input: photo you took with your phone. Box: digital filters. Output: social media-worthy photograph.

\begin{marginfigure}
  \input{figures/introduction/example-ice-cream.tex}
  % \input{figures/introduction/fundamental-diagram.tex}
  \caption{\label{fig:intro-example-ice-cream} Total preparation time is about 15 minutes plus a 20 minutes soft freeze in the ice cream maker followed by an overnight hard freeze in the freezer.\vskip 5pt Milk by Wawan Hermawan and Ice Cream by Landan Lloyd from the Noun Project.}
\end{marginfigure}


Example. Input: 1 cup of whole milk, 2 cups of heavy cream, 1/2 tsp of Kosher salt, 2/3 cup of granulated sugar. Box: Ice cream maker. Output: Sweet cream ice cream.

Example. Input: a day of the week. Box: Weekly calendar. Output: The things I have to do that day.

Example. Input: the address of a website. Box: A web browser. Output: The web page at that address.

Example. Input: A form that says, "Do you like me? Yes, no, or maybe". Box: My secret crush. Output: Jubilation or heartbreak

Example. Input: Contestants on a game show. Box: The celebrity panel of judges. Output: The winner.

Example. Input: Keywords. Box: A search engine. Output: Search results related to your keywords.

This is the same as a question and answer. Request and reponse. Order and delivery. It shows up over and over and over again. Get ready to see it throughout this book. Whenever you get lost in a program---and everyone does; I do multiple times a day---stop and ask yourself, ``What inputs have I received? What outputs am I supposed to make from them?'' Start there and work your way from one to the other, forwards or backwards.

Exercise. Come up with an example that the Fundamental Diagram of Computer Science models. Draw and label your diagram.
Exercise. Now come up with another.
Exercise. And one more.


Programming can feel complicated. And a lot of times it is. But underneath all the bells and buzzwords of programming, there are really only four things you can do:

\begin{enumerate}
  \item Store information somewhere and use it later.
  \item Conditionally do something.
  \item Repeat things.
  \item Organize the machinery of (1), (2), and (3) into reusable chunks.
\end{enumerate}

If you can master those four things, you will have mastered software engineering.

\section{Storing information}
Storing information is at the heart of software. Data is king. You see it everywhere, from advertisers to political campaigns, scientific experiments, and your email. In programming, we have to decide \textit{what} data to keep around and \textit{how} to store it.

You have come across many different data storage mechanisms. Data can be saved to files on disk, stored in a database, on your computer, on another computer that you access via the internet, or on external hard drive. In programs we have other choices that we'll learn about soon.

The power of data does not come solely from storing it. Buried treasure isn't valuable until you dig it up and use it. So, too, with data. To be useful, we need to be able to retrieve and employ the data we have stored to complete a task. Many technologies have been created simply to make finding the data you're looking for fast and efficient. This is the purview of databases and key-value stores. But also of variables, objects, and data structures.

The actual mechanism you use to store and retrieve your data isn't especially important right now. All that you should remember is that in programming you can jot down some important information and use it again later.

\section{Conditional execution}
\section{Repeating}
\section{Organization}

How you structure an email is different from how you structure a novel. Good writing is tailored to the task at hand. There are two consumers of your code: the compiler, which turns it into instructions the computer can execute. But more importantly, PEOPLE---including future you! Programs are human-readable, not machine readable. Remember, the compiler is a translator; it translates the human-readable code that a \emph{human} wrote into something a human \emph{cannot} read. (Unless you're my friend EJ or my coworker Jay.) Good programming has the same hallmarks as good writing does, because that's what it is: it's a kind of writing. That's why we call them programming \emph{languages}. When you write code, you should strive to be clear. That means structuring your code in a way that shows intent: using convenient data structures and other abstractions. Encapsulating. Using simple control structures instead of fancy ones. Be explicit (no globals or other captured scope). Principle of least surprise. Make it look like someone else wrote the code: copy the style and conveniention, even if it's not your own. Cognitive load is real. Context switching is real. Keep the styles the same.

Style is a holy war. Nothing is perfect. Always trade-offs. Often it's a matter of taste and who the fuck cares. (Where to place the brackets.)
