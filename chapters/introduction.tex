\setchapterpreamble[u]{\margintoc}
\chapter{Introduction}

Computer science is ths study of what we can compute. Computer scientists try to answer questions like, are there unavoidable limits on the programs we can write? (The answer is \emph{yes}. Some programs are impossible to write no matter what.) And are there unavoidable limits on how slow some programs have to run? (The answer again is yes. We'll see an example of a performance limit later on.) Software engineering is concerned not with whether it is possible to build something---they take the fact that their project can be built for granted---but rather how can the project be built \emph{cheaply}. Software engineers are concerned with how much the project costs, how much time the software takes to run, how much memory it consumes---and, most importantly, whether the whole thing can be shipped to the customer on schedule.

Sucessful programmers need to use a mix of tricks from computer science and software engineering. Generally the two fields grow from one another. Engineers sometiems stumble onto a new, unsolved problem during the course of working on their projects. In the process of completing the project, new computer science is made. Researchers cook up new algorithms to solve outstanding problems in the field. In the process they invent new programming techniques. Those new techniques make it back to the engineers, who then apply them in new projects. And so the cycle goes on and on. What computer scientists and software engineers do aren't that different. They approach similar problems with different perspectives. To be a sucessful programmer, you will sometimes want to think like a computer scientist and sometimes like a software engineer. Fortunately, both perspectives come from the same underlying idea of computation, which can be drawn very neatly in a diagram---the \emph{fundamental diagram}.

\section{The Fundamental Diagram}
The \textbf{Fundamental Diagram} is at the heart of everything software engineers and computer scientists do.\sidenote{Full disclaimer: I might be the only person who calls this the Fundamental Diagram. But everyone should. Like reading, this diagram is fundamental.} As a programmer, you'll get to know this picture very well. It shows up in just about every concept you'll ever encounter---from the very big, to the obnoxiously small.

\begin{figure}[h]
  \input{figures/introduction/fundamental-diagram.tex}
  \caption{\label{fig:intro-fundemental-diagram} The Fundamental Diagram of computer science and software engineering in all its glory. It describes just about everything a programmer could possibly do.}
\end{figure}

Fortunately, the diagram doesn't have many parts. There are just three: the inputs, the outputs, and the transformer. The transformer takes in \emph{inputs} and \emph{transforms} them into \emph{outputs}. That's it. As a programmer, you will write software that turns specific inputs into particular outputs to accomplsh a given task. If that description sounds vague, that's because it is. Let's look at a few examples to see the Fundamental Diagram in action to get a better idea of what's going on.

\paragraph{Example (Question and Answer)} A lot of human interaction follows the input-transformer-output pattern. Questions and answers can be modeled by the fundamental diagram pretty easily. For example, ``What's your favorite color?''\sidenote{The answer is orange. Well, it is if I am the transformer being asked. You might come up with a different but correct answer. Different transformers can give different answers to the same question.} But what is the transformer in this case? The transformer is the person who gives the answer to the question; she listens to a question asked by somebody else, processes what it means, and then produces an answer. For historical reasons---think ancient Greek history---sometimes the role of the transformer in a Q\&A session is called an \emph{oracle}.

\begin{figure}[h]
  \input{figures/introduction/example-question-answer.tex}
  \caption{\label{fig:intro-example-question-answer} Fundamental diagram for a question, oracle, and answer.}
\end{figure}

\paragraph{Example (Request and Response)}The same can be said of slightly different kind of speech act called a \emph{request}. People make requests all the time. ``Can you close the door, please?'' ``May I have the lobster sandwich and a raspberry lime rickey?'' ``That'll be \$49.99, please.'' Each of these statements intend to turn simple words into actions that produce some physical effect---producing closed door, a lobster sandwich and a raspberry lime rickey, or money totaling \$49.99.

\begin{question}
  Identify the inputs, outputs, and transformers for the requests above.
\end{question}

\begin{question}
  Draw the fundamental diagrams for each of the requests above.
\end{question}

On the web, requests are ubiquitous. When you open a web browser and type in the address of a web page, the web browser makes a formal request to the machine located at that address. \sidenote{In the same way individual people have street addresses---like Sirius Black, who resided at 12 Grimmauld Place, London---computers have internet addresses, too. These computers are called \emph{web servers}. Like the computer which resides at the address \texttt{www.dafk.net}.\vskip 5pt Individual web pages reside on web servers. For example, the webapge \texttt{what} resides on the computer with the address \texttt{www.darfk.net}. Its full address is \texttt{www.darfk.net/what}.} The terminology for the actors in a web request comes from the restaurant industry. At restaurants, clients make requests to people called servers, who fulfill their clients' requests (usually with the help of many other people who are not client-facing).

This pattern of request and response is exactly how the world wide web works. The piece of software that initiates the request is called the \emph{client}. Because this is the software that human users can see, people sometimes say client technology is \emph{front end} technology. The software that receives, processes, and sends back a response to the client is called the \emph{server}. The server is not something that human users interact with directly. We don't get to see what the server is doing, only the response that it produced. This is a lot like how clients at a restaurant don't get to interact with the kitchen directly. Instead they get to experience the finished product---but they don't get know how the sausage is made, so to speak. Because the server's work to transform a request into a full web page response is opaque to the user, we say that servers a \emph{back end} technology.

\begin{figure}[h]
  \input{figures/introduction/example-request-response.tex}
  \caption{\label{fig:intro-example-request-response} Fundamental diagram for a request, server, and response.}
\end{figure}

The client-server architecture, like the fundamental diagram, is deceptively simple and yet it powers the whole of the internet.\sidenote{Software engineers call the organization of data flows an \emph{architecture}. In this case, the flow of information is the request from the client to the server and the response from server to client.} Web programming is a specialized collection of technologies, many of which we'll encounter in this series. When you're bushwacking the jargon and buzzwords of the web technology jungle, stop and remember Figure \ref{fig:intro-example-request-response}: just two arrows and a box in the middle. Almost all of the latest and greatest technologies are just fancy ways to request some piece of data from a server. Always keep this picture in mind.

\paragraph{Example (Making Ice Cream)} Recipes are hands-down the tastiest kinds of transformers.Recipes explain how to transform ingredients into prepared dishes. Here's one I like because it's quick, easy, and the result is something near and dear to my heart: ice cream.

\begin{marginfigure}
  \input{figures/introduction/example-ice-cream.tex}
  \caption{\label{fig:intro-example-ice-cream} Total preparation time is about 15 minutes plus a 20 minutes soft freeze in the ice cream maker followed by an overnight hard freeze in the freezer.\vskip 5pt Milk by Wawan Hermawan and ice cream by Landan Lloyd from the Noun Project.}
\end{marginfigure}

Up until now, each transformer we've described takes exactly one input and produces a single output. Here is our first example of a transformer that takes multiple inputs to produce its output. It is not uncommon for a transformer to take multiple inputs. There are very few recipes that require just a single ingredient. So, too, programs often need to use combine multiple inputs to generate a desired output.

Let's look at the process to transform a few ingredients into ice cream in some detail. Below is a kind of step-by-step list of instructions that transform the input ingredients milk, cream, sugar, and salt, into ice cream. Each step goes on its own line. As a general rule, steps should be kept as simple as possible. Complex steps should be broken up into multiple, simpler steps. This strategy makes it easier for the person preparing the recipe to understand and execute. The programs we write to transform inputs into outputs will have a very similar character.

\suppresslinenumbers
\begin{lstlisting}[caption={\label{listing:intro-ice-cream} Ice cream transformer. It's as short as it is sweet.}, escapeinside=$$, firstnumber=0]
$\textbf{Inputs:}$ 1 c. whole milk
        2 c. heavy cream
        2/3 c. sugar
        1/2 tsp. Kosher salt

$\textbf{Output:}$ Sweet cream ice cream
$\reactivatelinenumbers$
Place the milk, heavy cream, sugar, and salt in a bowl.
Mix until the sugar has completely dissolved.
Pour the ice cream base into an ice cream maker.
Run the machine until the base mixture firms up.
Transfer the cold cream into a sealed container.
Chill the container in a freezer overnight.$\suppresslinenumbers$
\end{lstlisting}

Did you notice that our great big ice cream transformer is made up of three smaller input-output transformers? The first one decribed on lines 1--2. It turns the input ingredients into a liquid base mixture. The next one on lines 3--4 takes as input the base mixture and outputs a cold cream. While cold cream is delicious, it melts extremely rapidly. And so the recipe finishes with the transformer on lines 5--6, which takes as input the cold cream and freezes it until to produce bona fide ice cream.

\begin{figure*}[h]
  \input{figures/introduction/example-ice-cream-pipeline.tex}
  \caption{\label{fig:intro-example-ice-cream-pipeline} The steps inside transformers are often simpler transformers. The transfromation that produces ice cream from ingredients is made up of three successive transformers. The output of one transformer is the input to the next transformer.}
\end{figure*}

Figure \ref{fig:intro-example-ice-cream-pipeline} illustrates that old saying, ``One transformer's output is another transformer's input.'' And that is the real power of the fundamental diagram. You can chain copies of it together to produce more and more complicated flows of inputs and outputs. In this case, we chained together three transformers in the simplest way possible, in a line, one after the other. The \emph{pipeline} pattern is very common in software architecture. In fact, many of the applications in ``big data'' reduce to pipelines of transformers, no different conceptually to the ice cream pipeline above. When we work with command line tools, we will meet the pipe operator that feeds the output of one program as the input to another.\sidenote{The pipe operator notated by the symbol `\texttt{|}`. It's that shift character on the backslash key. Now go lay some pipe!} It acts like a pipe for the information to flow through. Hence the name \emph{pipe}.

\begin{question}
  In the style of Listing \ref{listing:intro-ice-cream}, write the inputs, outputs, and steps to create a grilled cheese sandwich.
\end{question}

\begin{question}
  Draw a fundamental diagram for your grilled cheese listing.
\end{question}

\begin{question}
  Come up with three more examples that can be modeled by the fundamental diagram.
\end{question}

\section{Four Friends of Programming}

There are lots of things to learn about engineering. New technologies are built every single day. And it is difficult to keep up. The shear number of things to know can be overwhelming. But fear not! There actually aren't that many different things you can do with a programming language. In fact, there are only four.\marginnote{The fact that there are only four things you can do is something of a theoretical marvel. It is related to \emph{Church-Turing thesis} and lies as the heart of the foundations of computing. Lucky for us, it means we need to learn only four concepts. Actually the fourth one, organization and reuse, is merely a convenience for us humans.} Any new technology or technique you run across is a cousin to one or more of the four friends you will make in this chapter. The four things you can do in a programming language are:

\begin{enumerate}
  \item \textbf{Store data and retrieve it later to use.}
  Your friend for the pillar of data storage and retrieval is a \emph{variable}. Other instances of this pillar include files, databases, networked resources, and web pages on the Internet. At their heart, however, they're all about stashing some information somewhere and fetching it later.

  \item \textbf{Conditionally do something.}
  Your friend for the pillar of conditional execution is the \textsf{if} statement. Other examples of this pillar include associative arrays, pattern matching, and \textsf{switch} statements. These technologies exist to add decision-making into programs. Conditional elements put the ``sometimes'' into programs that would otherwise be ``always'' based on context and circumstance.

  \item \textbf{Repeat things.}
  The ability to repeat things quickly is what makes computers so useful. Your friend for the pillar of repetition is the \textsf{for}~loop. Other examples of this pillar include \textsf{while}~loops and \textsf{do-while}~loops, recursion, and coroutines. At their core, however, the whole point is to repeat something.

  \item \textbf{Organize 1--3 into reusable pieces.}
  This last pillar isn't technically required, but it perhaps the most useful.\marginnote{See, for example, the controversy about whether or not to put curly braces on their own line or not: https://en.wikipedia.org/wiki/Indentation\_style.} It's all about organizing our programs into pieces that are easy for people to read, understand, expand, troubleshoot, and fix. This pillar could also be called \emph{style}. Your friend from this pillar is \emph{function}. Other members of the pillar include libraries, modules, closures, classes, and design patterns\marginnote{People write full books on programming style and they almost always disagree on what ``best'' practices are.}. Since style is often a matter of taste, this pillar is the most contentious and is the basis of many religious wars.
\end{enumerate}

That's it! Master the four pillars of programming and you can confidently tackle any project. That is not to say that these four skills are easy to master. Mastery is hard work. But when you find yourself learning something new, ask yourself, ``Which of my four friends is this new friend most like?'' Or if you are stuck implementing a solution and aren't sure what to do, ask yourself, ``Which of my four friends could help me most right now?''

\subsection{Data Types}
Before we can talk about storing and using information, we need to talk about how we represent information in programs in the first place. In programming, we use data types to represent information. A \emph{data type} is a collection of values and operations that you can apply to those values. Each piece of information in a program has three parts:

\begin{itemize}
  \item Name
  \item Data Type
  \item Value
\end{itemize}

Since each value in a program belongs to a data type---data types are how we represent information, after all---type and value are always associated with a piece of data. Names, however, are optional. When an element of a data type is associated with a name, we call it a \emph{variable}. A variable is a data type value that has a name. An element of a data type that does not have a name is called a \emph{literal value}. The diffrence between a variable and a literal value is that you can use the name of a variable to reference it later. Literal values, however, need to be used immediately and cannot be referened later in your program---because they don't have a name to call them later!

NodeJS has a handful of built-in data types. The most familiar one will be the \texttt{Number} data type. You won't be surprised to learn that the \texttt{Number} data type is used to represent numerical values in NodeJS.




%
% \paragraph{Example (Compilers and Interpreters)}
%
% This is the same as a question and answer. Request and reponse. Order and delivery. It shows up over and over and over again. Get ready to see it throughout this book. Whenever you get lost in a program---and everyone does; I do multiple times a day---stop and ask yourself, ``What inputs have I received? What outputs am I supposed to make from them?'' Start there and work your way from one to the other, forwards or backwards.
%
%
%
% \section{Programming}
% Programming can feel complicated. And a lot of times it is. But underneath all the bells and buzzwords of programming, there are really only four things you can do:
%
% \begin{enumerate}
%   \item Store information somewhere and use it later.
%   \item Conditionally do something.
%   \item Repeat things.
%   \item Organize the machinery of (1), (2), and (3) into reusable chunks.
% \end{enumerate}
%
% If you can master those four things, you will have mastered software engineering.
%
% \section{Storing information}
% Storing information is at the heart of software. Data is king. You see it everywhere, from advertisers to political campaigns, scientific experiments, and your email. In programming, we have to decide \textit{what} data to keep around and \textit{how} to store it.
%
% You have come across many different data storage mechanisms. Data can be saved to files on disk, stored in a database, on your computer, on another computer that you access via the internet, or on external hard drive. In programs we have other choices that we'll learn about soon.
%
% The power of data does not come solely from storing it. Buried treasure isn't valuable until you dig it up and use it. So, too, with data. To be useful, we need to be able to retrieve and employ the data we have stored to complete a task. Many technologies have been created simply to make finding the data you're looking for fast and efficient. This is the purview of databases and key-value stores. But also of variables, objects, and data structures.
%
% The actual mechanism you use to store and retrieve your data isn't especially important right now. All that you should remember is that in programming you can jot down some important information and use it again later.
%
% \section{Conditional execution}
% \section{Repeating}
% \section{Organization}
%
% How you structure an email is different from how you structure a novel. Good writing is tailored to the task at hand. There are two consumers of your code: the compiler, which turns it into instructions the computer can execute. But more importantly, PEOPLE---including future you! Programs are human-readable, not machine readable. Remember, the compiler is a translator; it translates the human-readable code that a \emph{human} wrote into something a human \emph{cannot} read. (Unless you're my friend EJ or my coworker Jay.) Good programming has the same hallmarks as good writing does, because that's what it is: it's a kind of writing. That's why we call them programming \emph{languages}. When you write code, you should strive to be clear. That means structuring your code in a way that shows intent: using convenient data structures and other abstractions. Encapsulating. Using simple control structures instead of fancy ones. Be explicit (no globals or other captured scope). Principle of least surprise. Make it look like someone else wrote the code: copy the style and conveniention, even if it's not your own. Cognitive load is real. Context switching is real. Keep the styles the same.
%
% Style is a holy war. Nothing is perfect. Always trade-offs. Often it's a matter of taste and who the fuck cares. (Where to place the brackets.)
