\chapter{Thoughts}

\section{Introduction}
What you need to know: The fundamental picture of Computer Science. What's in the magic box? 1. Ability to store information and retrieve it later. 2. Ability to conditionally do things. 3. Ability to repeat. 4. The ability to organize things 1--3 into re-usable bits. (This is a bonus, actually.)

Examples. Fetching a web page: request/response. Mathematical functions. Database query/rows. But also literally any question and answer.

To write this down, we will use code in a programming language. What is code? Who is it for? Interpreters and compilers. We use Python---widely used in industry, hot in data science and ML. Lots of resources for it. But you should also learn languages that from other paradigms: LISP, Scheme, Erlang, Haskell, Prolog, SQL. (You'll learn some SQL later in this series.)

But we're not just theoreticians. We're also engineers, who want to build things that run, so we can make MON-EY. So we're also concerned with resource consumption. Two special ones are time and (disk) space/memory. How fast? And how much? So we'll learn to reason about the complexity of our code and profile it to see where the bottlenecks are. A lot of this is back-of-the-envelop calculation. And we use this all the time to estimate how much money it will take for a project to run. Sure, we can speed it up by using fancy GPUs, but will the project pay for itself or will the speed-up send us into bankruptcy?

\section{}

\section{Looking for a Job}
Theory of company: small, medium, large. What do you want from a job? Learning. Money. Vacation. Regular hours. Working exciting projects.

\section{How to interview} What are interviewers looking for? You are the solution to a problem. Will you make it easier for everyone to do their jobs or harder? (In what ways? This is culture fit.) But typically looking for three things: how do you communicate, how do you make decisions, how do you respond to changes or ambiguity.
