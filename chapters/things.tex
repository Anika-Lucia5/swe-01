\chapter{Thoughts}
%
% \paragraph{Example (Compilers and Interpreters)}
%
% This is the same as a question and answer. Request and reponse. Order and delivery. It shows up over and over and over again. Get ready to see it throughout this book. Whenever you get lost in a program---and everyone does; I do multiple times a day---stop and ask yourself, ``What inputs have I received? What outputs am I supposed to make from them?'' Start there and work your way from one to the other, forwards or backwards.
%
%
%
% \section{Programming}
% Programming can feel complicated. And a lot of times it is. But underneath all the bells and buzzwords of programming, there are really only four things you can do:
%
% \begin{enumerate}
%   \item Store information somewhere and use it later.
%   \item Conditionally do something.
%   \item Repeat things.
%   \item Organize the machinery of (1), (2), and (3) into reusable chunks.
% \end{enumerate}
%
% If you can master those four things, you will have mastered software engineering.
%
% \section{Storing information}
% Storing information is at the heart of software. Data is king. You see it everywhere, from advertisers to political campaigns, scientific experiments, and your email. In programming, we have to decide \textit{what} data to keep around and \textit{how} to store it.
%
% You have come across many different data storage mechanisms. Data can be saved to files on disk, stored in a database, on your computer, on another computer that you access via the internet, or on external hard drive. In programs we have other choices that we'll learn about soon.
%
% The power of data does not come solely from storing it. Buried treasure isn't valuable until you dig it up and use it. So, too, with data. To be useful, we need to be able to retrieve and employ the data we have stored to complete a task. Many technologies have been created simply to make finding the data you're looking for fast and efficient. This is the purview of databases and key-value stores. But also of variables, objects, and data structures.
%
% The actual mechanism you use to store and retrieve your data isn't especially important right now. All that you should remember is that in programming you can jot down some important information and use it again later.
%
% \section{Conditional execution}
% \section{Repeating}
% \section{Organization}
%
% How you structure an email is different from how you structure a novel. Good writing is tailored to the task at hand. There are two consumers of your code: the compiler, which turns it into instructions the computer can execute. But more importantly, PEOPLE---including future you! Programs are human-readable, not machine readable. Remember, the compiler is a translator; it translates the human-readable code that a \emph{human} wrote into something a human \emph{cannot} read. (Unless you're my friend EJ or my coworker Jay.) Good programming has the same hallmarks as good writing does, because that's what it is: it's a kind of writing. That's why we call them programming \emph{languages}. When you write code, you should strive to be clear. That means structuring your code in a way that shows intent: using convenient data structures and other abstractions. Encapsulating. Using simple control structures instead of fancy ones. Be explicit (no globals or other captured scope). Principle of least surprise. Make it look like someone else wrote the code: copy the style and conveniention, even if it's not your own. Cognitive load is real. Context switching is real. Keep the styles the same.
%
% Style is a holy war. Nothing is perfect. Always trade-offs. Often it's a matter of taste and who the fuck cares. (Where to place the brackets.)


\section{Introduction}
What you need to know: The fundamental picture of Computer Science. What's in the magic box? 1. Ability to store information and retrieve it later. 2. Ability to conditionally do things. 3. Ability to repeat. 4. The ability to organize things 1--3 into re-usable bits. (This is a bonus, actually.)

Examples. Fetching a web page: request/response. Mathematical functions. Database query/rows. But also literally any question and answer.

To write this down, we will use code in a programming language. What is code? Who is it for? Interpreters and compilers. We use Python---widely used in industry, hot in data science and ML. Lots of resources for it. But you should also learn languages that from other paradigms: LISP, Scheme, Erlang, Haskell, Prolog, SQL. (You'll learn some SQL later in this series.)

But we're not just theoreticians. We're also engineers, who want to build things that run, so we can make MON-EY. So we're also concerned with resource consumption. Two special ones are time and (disk) space/memory. How fast? And how much? So we'll learn to reason about the complexity of our code and profile it to see where the bottlenecks are. A lot of this is back-of-the-envelop calculation. And we use this all the time to estimate how much money it will take for a project to run. Sure, we can speed it up by using fancy GPUs, but will the project pay for itself or will the speed-up send us into bankruptcy?

\section{List of Topics}
\begin{itemize}
  \item variable: name, type, value
  \item data types: values and operations
  \item literal values
  \item constants
  \item reference types (also, why copying a file is slow, but moving it is fast)
  \item testing for equality
  \item comments

  \item list
  \item set
  \item dictioary
  \item data structures
  \item dictionary-backed set, list-backed set, tree-backed set
  \item interface, implementation

  \item cat, less, wc, grep, sort, uniq, cd, ls
  \item directories, files

  \item version control
  \item commit/patch
  \item branch

  \item exception handling (it's just another way to return multiple things)
  \item catch at the top
  \item stack traces
  \item debugging strategies

  \item functions
  \item scope
  \item asynchronous execution
  \item i/o
  \item networking functions

  \item http request/response
  \item client/server architecture

  \item unit tests
  \item profiling
  \item estimating cost

  \item code rot
  \item legacy code --- be generous. engineers who came before you were not idiots
  \item refactoring
  \item no nested if-statements
  \item global variables bad
  \item single purpose
  \item abstraction
  \item encapsulation
  \item be explicit
  \item principle of least surprise

  \item design patterns
  \item iterator pattern
  \item mvc
  \item databases
  \item CRUD
  \item select, insert, update, delete
  \item joins: left, right, inner, outer

  \item objects: a collection functions with the same first argument
  \item static methods and members
  \item composition over inheritance
  \item immutability
  \item private state
  \item abstract classes --- template pattern
  \item looking things up before asking for help
  \item asking for help often
  \item reading the docs
\end{itemize}

\section{Looking for a Job}
Theory of company: small, medium, large. What do you want from a job? Learning. Money. Vacation. Regular hours. Working exciting projects.

\section{How to interview} What are interviewers looking for? You are the solution to a problem. Will you make it easier for everyone to do their jobs or harder? (In what ways? This is culture fit.) But typically looking for three things: how do you communicate, how do you make decisions, how do you respond to changes or ambiguity.

Overcommunicate. Tell them what you're thinking, even if it's uncertain. Don't wait until the end. They aren't evaluating your answer. They are evaluating \emph{how} you find answers.
