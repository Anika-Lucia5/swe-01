\chapter{Thoughts}

\section{Introduction}
What you need to know: The fundamental picture of Computer Science. What's in the magic box? 1. Ability to store information and retrieve it later. 2. Ability to conditionally do things. 3. Ability to repeat. 4. The ability to organize things 1--3 into re-usable bits. (This is a bonus, actually.)

Examples. Fetching a web page: request/response. Mathematical functions. Database query/rows. But also literally any question and answer.

To write this down, we will use code in a programming language. What is code? Who is it for? Interpreters and compilers. We use Python---widely used in industry, hot in data science and ML. Lots of resources for it. But you should also learn languages that from other paradigms: LISP, Scheme, Erlang, Haskell, Prolog, SQL. (You'll learn some SQL later in this series.)

But we're not just theoreticians. We're also engineers, who want to build things that run, so we can make MON-EY. So we're also concerned with resource consumption. Two special ones are time and (disk) space/memory. How fast? And how much? So we'll learn to reason about the complexity of our code and profile it to see where the bottlenecks are. A lot of this is back-of-the-envelop calculation. And we use this all the time to estimate how much money it will take for a project to run. Sure, we can speed it up by using fancy GPUs, but will the project pay for itself or will the speed-up send us into bankruptcy?

\section{List of Topics}
\begin{itemize}
  \item variable: name, type, value
  \item data types: values and operations
  \item literal values
  \item constants
  \item reference types (also, why copying a file is slow, but moving it is fast)
  \item testing for equality
  \item comments

  \item list
  \item set
  \item dictioary
  \item data structures
  \item dictionary-backed set, list-backed set, tree-backed set
  \item interface, implementation

  \item cat, less, wc, grep, sort, uniq, cd, ls
  \item directories, files

  \item version control
  \item commit/patch
  \item branch

  \item exception handling
  \item catch at the top
  \item stack traces
  \item debugging strategies

  \item functions
  \item scope
  \item asynchronous execution
  \item i/o
  \item networking functions

  \item http request/response
  \item client/server architecture

  \item unit tests
  \item profiling
  \item estimating cost

  \item code rot
  \item legacy code --- be generous. engineers who came before you were not idiots
  \item refactoring
  \item no nested if-statements
  \item global variables bad
  \item single purpose
  \item abstraction
  \item encapsulation
  \item be explicit
  \item principle of least surprise

  \item design patterns
  \item iterator pattern
  \item mvc
  \item databases
  \item CRUD
  \item select, insert, update, delete
  \item joins: left, right, inner, outer

  \item objects: a collection functions with the same first argument
  \item static methods and members
  \item composition over inheritance
  \item immutability
  \item private state
  \item abstract classes --- template pattern
  \item looking things up before asking for help
  \item asking for help often
  \item reading the docs
\end{itemize}

\section{Looking for a Job}
Theory of company: small, medium, large. What do you want from a job? Learning. Money. Vacation. Regular hours. Working exciting projects.

\section{How to interview} What are interviewers looking for? You are the solution to a problem. Will you make it easier for everyone to do their jobs or harder? (In what ways? This is culture fit.) But typically looking for three things: how do you communicate, how do you make decisions, how do you respond to changes or ambiguity.

Overcommunicate. Tell them what you're thinking, even if it's uncertain. Don't wait until the end. They aren't evaluating your answer. They are evaluating \emph{how} you find answers.
