\chapter{Preface}

\section*{How to Use the Workbook}
The workbook guides you through some of the nitty-gritty stuff that isn't included in programming books because, well, it's not technically part of programming. But skills like navigating directories on the command line, running programs, and choosing a text editor are unspoken dependecies for writing, debugging, and publishing your software.

This text is a supplement, not a replacement, to SWE Book Level 1. You should read and understand everything in that text. That's where the meat of programming lives. That book is about software development. This workbook is about software and systems operation. They are two sides of the same coin. And as a burgeoning software engineer, you need to be comfortable with both sides.

There is a desire to use fancy tools that automate some of these tasks for you---and in doing so, relieve you of the burden of learning how they are done. That approach works, until it doesn't. Inevitably, the tool you use will not work for a use case you need. Worse, it may not work as advertised on a case you expect it to. At that point, you will need to investigate the problem and cook up a solution yourself. That's precisely what this workbook will prepare you to do: troubleshoot, problem solve, and overcome system administration and operational difficulties surrounding software engineering.

\section*{Technologies}
The book will reference technologies and versions currently available. There is an inherent danger and kind of shame associated with tying a book to a particular version of software that every author dreads and tries to avoid: the curse of being dated.

In no time flat, new versions of software will be released. Flashy new technologies heretofore unimagined and unknown will come into existence. And they will make this book appear obsolete. I am aware of this particular peril and preparing my ego accordingly. I am keenly aware that beginning engineers---in fact all engineers---do, in actual fact, run actual software on their actual computers. And in doing so lock themselves into particular software and particular versions of that software in the process. We will set them up together first thing in Chapter \ref{chapter:intro}.
