\chapter{Preface}

This is the first in a series of short books for people who'd like to get a job in software engineering but who haven't programmed before. These texts are self-paced and build on each other, incorporating skills and concepts used by engineers on the job every day. You're reading the introduction to Level 1.

\section*{Differences from CS 50}
Harvard's CS 50: Introduction to Computer Science is pretty famous. It's a good course, but it's designed for cross-purposes. On the one hand, it's a university course designed for college students who plan to major in computer science. And on the other hand, it is designed to give students who do not plan to major in computer science enough information to build a web app. In my opinion, CS 50 simultaneously does too much and too little to be useful for people who want to make a career in software engineering. It really should dig in deeper into the theory or deeper in the practice.

\section*{Difference from a Programming Bootcamp}
Bootcamps do a good job introducing students to partiular frameworks and specific technologies. And after completing a bootcamp, students have real, living, working completed projects---often web apps---but no real understanding how they work. Web frameworks are plug-and-play. You wire up the built-in components together to do the basic functions in web apps. As soon as projects require a feature that isn't built-in to the framework---as will definitely happen once they get a job---bootcamps stop helping. Bootcamps tend to teach how to use technology, but not how to think and problem like an engineer.

\section*{Our Approach}
This series focuses on thinking and buildling like an engineer does. The content is based on the kinds of problems that engineers experience daily and works through common solutions with an emphasis on transferable skills that apply to all engineering jobs in software---be it web development, mobile app development, backend development, and frontend development.

The series aims to develop core skills and a working intution about programs. After completing this series you will be able to reason about common engineering tasks and problem solve new engineering problems like an software engineer.

We use NodeJS as our language of instruction. NodeJS is a server-side version of JavaScript. We settled on JavaScript for a few reasons. Firstly, JavaScript is the language of the internet. Every browser contains a JavaScript engine. As a result, JavaScript is the most widely supported programming langauge in the entire world. Because you already have a web browser installed on your computer, anyone can start programming without having to set anything up. Because there's nothing initally to set up, you can start programming right away, right now!

Secondly, the syntax and semantics of JavaScript are fairly representative of commonly used programming langauges. Learning JavaScript makes it easy to move to Python or Swift with relatively little extra work.

\section*{Background and Expectations}
This book assumes not previous programming experience. But it does expect that you will read the book carefully, work through the examples, and answer all of the in-text questions, and complete all of the exercises.

Programming is a skill. It is not a set of facts. It is a practice. In order to become a seasoned programmer, you need to program. \emph{A lot.} Watching someone else paint a painting doesn't make you a painter. The only way to become a painter, you need to get your hands dirty, ruin some brushes, and produce a few bad paintings. So, too, with programming. We are going to get real cozy with stack traces, error messages produced by buggy code, and learn to love them.

There is no magic bullet solution. This series will guide you up the mountain of software engineering. But it is a mountain. And it will take time and energy. I know you can do it!
